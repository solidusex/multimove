#ifndef __MMCORE_NEGMSG_H__
#define __MMCORE_NEGMSG_H__

#include "../Common/common.h"

MM_NAMESPACE_BEGIN



/*在server端，如果位置为NM_POS_LEFT， 则证明此台计算机在Client的左侧，否则反之*/
typedef enum
{
		NM_POS_LEFT = 0x00,
		NM_POS_RIGHT,
		
		NM_POS_MAX
}nmPosition_t;


#define NM_KEEPALIVE_TIMEOUT			10 * 1000		/*1000秒钟没有任何socket上的IO操作则认为该客户端已不存在*/
#define NM_TIMER_TICK					1  * 1000		/*2秒检查一次*/


#define NM_BLOCKING_TIMEOUT				20				/*所有阻塞等待最长为20毫秒*/
#define NM_SEND_TIMEOUT					3 * 1000		/*发送时阻塞超时*/



typedef enum
{
		NM_MSG_HANDSHAKE = 0x00,		/*Client -> Server*/
		NM_MSG_HANDSHAKE_REPLY,			/*Server -> Client*/

		NM_MSG_ENTER,					/*Client -> Server*/
		NM_MSG_LEAVE,					/*Server -> Client*/

		NM_MSG_MOUSE,					/*Client -> Server*/
		NM_MSG_KEYBOARD					/*Client -> Server*/
}nmMsgType_t;



typedef struct __handshake_msg_tag
{
		nmPosition_t	srv_pos;
}nmHandShakeMsg_t;


typedef struct __enter_msg_tag
{
		uint_32_t		src_x_fullscreen;
		uint_32_t		src_y_fullscreen;
		int_32_t		x;
		int_32_t		y;
}nmEnterMsg_t;


typedef struct __leave_msg_tag
{
		uint_32_t		src_x_fullscreen;
		uint_32_t		src_y_fullscreen;
		int_32_t		x;
		int_32_t		y;
}nmLeaveMsg_t;


typedef struct __mouse_msg_tag
{
		uint_32_t	msg;
		int_32_t	x;
		int_32_t	y;
		int_32_t	data;		/*滚轮偏移*/
}nmMouseMsg_t;


typedef struct __keyboard_msg_tag
{
		byte_t			vk;
		byte_t			scan;
		bool_t			is_keydown;
}nmKeyboardMsg_t;



typedef struct __netmsg_tag
{
		nmMsgType_t		t;
		union{
				nmHandShakeMsg_t		handshake;
				nmEnterMsg_t			enter;
				nmLeaveMsg_t			leave;
				nmMouseMsg_t			mouse;
				nmKeyboardMsg_t			keyboard;
		};
}nmMsg_t;



bool_t	NM_MsgToBuffer(const nmMsg_t	*msg, cmBuffer_t		*out);
bool_t	NM_ParseFromBuffer(const byte_t *data, size_t len, nmMsg_t	*msg);






/*

传输协议，以下不论Client->Server或者Server->Client，均为网络字节序

1. Client -> Server:
[0-4)字节 包长度
[4-6)字节 包类型 分为KeepAlive = 0, HandShake = 1, MouseEnter = 2, MouseEvent = 3, KeyboardEvent = 4

Content:

KeeyAlive:		Content length == 0 字节 
				包总长度为6字节


HandShake:		Content length == 1字节		
				[6-7)字节	direction	byte_t	方向 LEFT == 0, RIGHT == 1
				包总长度为7字节

MouseEnter:		Content length == 16字节
				[6-10)字节 : src_x_fullscreen	:  uint_32_t; 源屏幕宽度
				[10-14)字节 : src_x_fullscreen	:  uint_32_t; 源屏幕高度
				[14-18)字节： x				:  int_32_t ; 鼠标x轴坐标
				[18-22)字节： y				:  int_32_t ; 鼠标y轴坐标

MouseEvent:		Content length == 16字节		
		[6- 10)字节:  msg;				uint_32_t 消息类型
		[10- 14)字节: x;				int_32_t  鼠标x轴坐标
		[14-18)字节:  y;				int_32_t  鼠标y轴坐标
		[18-22)字节:  data;				int_32_t  特殊数据，例如滚轮偏移


KeyboardEvent:	Content length == 3字节			
		[6-7)字节： vk;				byte_t			虚拟键盘码
		[7-8)字节:	 scan;				byte_t			扫描码
		[8-9)字节:	 is_keydown			bool_t			是否为键被按下

		包总长度为9字节





2. Server -> Client:
[0-4)字节  包长度
[4-6)字节  包类型, 分为KeepAlive = 0, HandShake = 1, MouseLeave = 2

Content:

KeeyAlive:		Content length == 0字节

HandShake:		Content length == 0字节

MouseLeave:		Content length == 0字节




*/




MM_NAMESPACE_END


#endif
